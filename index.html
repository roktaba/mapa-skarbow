<!doctype html>
<html lang="pl">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
  <title>Mapa SkarbÃ³w</title>
  <link rel="preconnect" href="https://unpkg.com">
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
  <style>
    :root {
      --bg: #f7f7fb;
      --fg: #1f2937;
      --brand: #ff7a00;
      --accent: #00a884;
      --muted: #94a3b8;
      --card: #ffffff;
      --danger: #e11d48;
      --x-size: 22px; /* rozmiar X (np. 18â€“26px) */
    }
    html, body { height: 100%; margin: 0; background: var(--bg); color: var(--fg); font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif; }
    .app { display: grid; grid-template-rows: auto 1fr auto; height: 100%; }
    header { display:flex; align-items:center; gap:.6rem; padding: .8rem 1rem; background: var(--card); box-shadow: 0 2px 10px rgba(0,0,0,.06); position: sticky; top: 0; z-index: 1000; }
    header h1 { font-size: 1.1rem; margin: 0; }
    header .badge { background: var(--brand); color: #fff; padding: .2rem .5rem; border-radius: 999px; font-weight: 700; font-size: .8rem; }

    #map { width: 100%; height: 100%; }
    .controls { position: absolute; top: 3.5rem; left: .75rem; z-index: 900; display: grid; gap:.4rem; }
    .btn { appearance: none; border: 0; background: var(--card); color: #111; padding: .55rem .7rem; border-radius: .8rem; box-shadow: 0 4px 16px rgba(0,0,0,.12); font-weight: 700; font-size: .9rem; }
    .btn:active { transform: translateY(1px); }
    .btn.brand { background: var(--brand); color: #fff; border: 3px solid #fff; box-shadow: 0 4px 12px rgba(0,0,0,0.4); }
    .btn.accent { background: var(--accent); color: #fff; }

    .panel { background: var(--card); padding: .8rem; border-top-left-radius: 1rem; border-top-right-radius: 1rem; box-shadow: 0 -8px 24px rgba(0,0,0,.08); }
    .row { display: flex; align-items: center; justify-content: space-between; gap:.5rem; }
    .progress { width: 100%; height: 10px; background: #e5e7eb; border-radius: 999px; overflow: hidden; }
    .progress > i { display:block; height: 100%; width: 0%; background: linear-gradient(90deg, var(--brand), var(--accent)); transition: width .3s ease; }

    .toast { position: fixed; left: 50%; bottom: 6rem; transform: translateX(-50%); background: #111827; color: #fff; padding: .7rem .9rem; border-radius: .8rem; box-shadow: 0 8px 20px rgba(0,0,0,.3); font-weight: 700; opacity: 0; pointer-events: none; transition: opacity .25s ease; }
    .toast.show { opacity: 1; }

    .leaflet-container { background: #dfe7ee; }
    /* X: sam znak, bez tÅ‚a; z biaÅ‚ym obrysem dla czytelnoÅ›ci */
    .x-marker { width: 100%; height: 100%; background: transparent; border: none; padding: 0; display: grid; place-items: center; }
    .x-marker > b { font-size: var(--x-size); color: var(--danger); -webkit-text-stroke: 2px #ffffff; text-shadow: 0 1px 0 #fff, 0 0 6px rgba(0,0,0,.35); line-height: 1; }
    .x-marker.found { opacity: .35; filter: grayscale(1); }
    .big { font-size: 1rem; padding: .8rem 1rem; }

    @media (display-mode: standalone) {
      header { display:none; }
      .panel { padding-bottom: calc(env(safe-area-inset-bottom) + 1rem); }
    }
  </style>
</head>
<body>
  <div class="app">
    <header>
      <span class="badge">ğŸ’</span>
      <h1>Mapa SkarbÃ³w</h1>
    </header>
    <div id="map"></div>

    <div class="controls">
      <button class="btn brand big" id="hintBtn">ğŸ—ºï¸ PodpowiedÅº</button>
      <button class="btn big" id="resetBtn">ğŸ” Reset</button>
      <button class="btn big accent" id="newGameBtn" title="Rozpocznij nowÄ… grÄ™">ğŸ†• Nowa gra</button>
    </div>

    <div class="panel">
      <div class="row" style="margin-bottom:.6rem">
        <strong>PostÄ™p</strong>
        <span id="counter">0/0</span>
      </div>
      <div class="progress"><i id="bar"></i></div>
      <div id="clue" style="margin-top:.6rem; color: var(--muted); font-weight: 600;">Kliknij â€ğŸ†• Nowa graâ€, a potem stukaj w mapÄ™, aby dodaÄ‡ X. Dla kaÅ¼dego podaj nazwÄ™ (wskazÃ³wkÄ™) oraz 4-cyfrowe hasÅ‚o. Gdy skoÅ„czysz, wybierz â€Nieâ€ w pytaniu o kolejny X.</div>
    </div>
  </div>

  <div class="toast" id="toast">Znaleziono skarb! ğŸ†</div>

  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
  <script>
    // === USTAWIENIA ===
    const MAP_IMAGE_URL = 'nowyplan.jpg';
    const CATCH_RADIUS_PCT = 3.5; // promieÅ„ â€trafieniaâ€ wzglÄ™dem krÃ³tszego boku mapy

    // Start bez punktÃ³w â€“ dodajesz je sam w trybie â€Nowa graâ€
    let TREASURES = []; // { id, posPct:[x%,y%], title, hint, pin:'1234' }

    // === STAN ===
    const state = {
      imageSize: null,
      editing: false, // edycja wÅ‚Ä…czana tylko przez â€Nowa graâ€
      found: new Set(JSON.parse(localStorage.getItem('foundTreasures') || '[]')),
    };

    const toast = (msg) => { const el = document.getElementById('toast'); el.textContent = msg; el.classList.add('show'); setTimeout(() => el.classList.remove('show'), 1400); };

    const map = L.map('map', { crs: L.CRS.Simple, zoomControl: false, minZoom: -2, maxZoom: 2, inertia: true });

    let markers = new Map();

    function getMaxZoomForImage() { return 2; }
    function pxToLatLng(x, y) { return map.unproject([x, y], getMaxZoomForImage()); }
    function latLngToPx(latlng) { return map.project(latlng, getMaxZoomForImage()); }
    function pctToPx(posPct) { const w = state.imageSize.w, h = state.imageSize.h; return [ (posPct[0] / 100) * w, (posPct[1] / 100) * h ]; }
    function catchRadiusPx() { const m = Math.min(state.imageSize.w, state.imageSize.h); return (CATCH_RADIUS_PCT / 100) * m; }

    function updateProgressUI() {
      const total = TREASURES.length;
      const foundCount = [...state.found].filter(id => TREASURES.some(t => t.id === id)).length; // tylko istniejÄ…ce
      document.getElementById('counter').textContent = `${foundCount}/${total}`;
      const pct = total ? Math.round((foundCount/total)*100) : 0;
      document.getElementById('bar').style.width = pct + '%';
    }

    function saveFound() { localStorage.setItem('foundTreasures', JSON.stringify([...state.found])); }
    function setClue(text) { document.getElementById('clue').textContent = text; }

    function addMarker(t) {
      const iconHtml = `<div class="x-marker ${state.found.has(t.id) ? 'found' : ''}"><b>âœ–</b></div>`;
      const icon = L.divIcon({ html: iconHtml, className: '', iconSize: [36, 36], iconAnchor: [18, 18] });
      const [x, y] = t.posPct ? pctToPx(t.posPct) : t.pos;
      const ll = pxToLatLng(x, y);
      const m = L.marker(ll, { icon }).addTo(map);
      m.on('click', () => {
        if (state.editing) {
          // W trakcie edycji â€“ popraw wskazÃ³wkÄ™ lub PIN, albo usuÅ„ punkt
          const action = prompt(`Edytujesz ${t.id}.
Wpisz nowÄ… wskazÃ³wkÄ™ i PIN oddzielone znakiem |, np.: Plac zabaw|1234
Aby USUNÄ„Ä† punkt, wpisz: USUÅƒ`);
          if (action === null) return;
          if (action.trim().toUpperCase() === 'USUÅƒ') {
            TREASURES = TREASURES.filter(x => x.id !== t.id);
            if (markers.has(t.id)) { map.removeLayer(markers.get(t.id)); markers.delete(t.id); }
            state.found.delete(t.id);
            saveFound(); updateProgressUI(); setClue(`UsuniÄ™to ${t.id}.`); return;
          }
          const parts = action.split('|');
          if (parts.length === 2) {
            const newHint = parts[0].trim(); const newPin = parts[1].trim();
            if (!/^\d{4}$/.test(newPin)) { toast('PIN musi mieÄ‡ 4 cyfry.'); return; }
            if (newHint) t.hint = newHint; t.pin = newPin; setClue(`Zaktualizowano ${t.id}.`);
          } else { toast('Podaj "wskazÃ³wkÄ™|PIN" albo USUÅƒ.'); }
        } else {
          onChestTap(t, m);
        }
      });
      markers.set(t.id, m);
    }

    function refreshMarkers() { markers.forEach(m => map.removeLayer(m)); markers.clear(); TREASURES.forEach(addMarker); updateProgressUI(); }

    let lastTapPx = { x: 0, y: 0 };

    function onChestTap(t, marker) {
      if (!state.imageSize) return;
      const center = marker.getLatLng();
      const centerPx = latLngToPx(center);
      const dist = Math.hypot(centerPx.x - lastTapPx.x, centerPx.y - lastTapPx.y);
      if (dist > catchRadiusPx()) { toast('PodejdÅº bliÅ¼ej miejsca X ğŸ‘£'); return; }
      // PIN wymagany do zdobycia
      const entered = prompt(`Aby zdobyÄ‡ skarb: ${t.title || t.hint || t.id}
Wpisz 4-cyfrowe hasÅ‚o:`);
      if (entered === null) return;
      if (!/^\d{4}$/.test(entered.trim())) { toast('HasÅ‚o musi mieÄ‡ dokÅ‚adnie 4 cyfry.'); return; }
      if (entered.trim() === (t.pin || '')) {
        if (!state.found.has(t.id)) {
          state.found.add(t.id); saveFound();
          toast('Brawo! Skarb zdobyty ğŸ†');
          marker.getElement()?.querySelector('.x-marker')?.classList.add('found');
          updateProgressUI();
          const allFound = [...state.found].filter(id => TREASURES.some(x => x.id === id)).length === TREASURES.length;
          if (allFound) setClue('Wszystkie skarby zdobyte! ğŸ‰');
        } else { toast('Ten skarb juÅ¼ masz âœ”ï¸'); }
      } else { toast('Niepoprawne hasÅ‚o. SprÃ³buj ponownie.'); }
    }

    // PodpowiedÅº losuje niezdobyty X i pokazuje jego wskazÃ³wkÄ™
    function showHint() {
      const remaining = TREASURES.filter(t => !state.found.has(t.id));
      if (!remaining.length) { setClue(TREASURES.length ? 'Wszystko zdobyte! ğŸ‰' : 'Brak punktÃ³w â€” rozpocznij â€ğŸ†• Nowa graâ€.'); return; }
      const t = remaining[Math.floor(Math.random()*remaining.length)];
      setClue(`WskazÃ³wka: ${t.hint || 'Rozejrzyj siÄ™ uwaÅ¼nie...'}`);
      const [x, y] = t.posPct ? pctToPx(t.posPct) : t.pos;
      map.setView(pxToLatLng(x, y), 1, { animate: true });
    }

    // Reset: zeruje tylko postÄ™p (zostawia punkty i ich PIN-y)
    function resetProgress() { state.found.clear(); saveFound(); refreshMarkers(); setClue('PostÄ™p wyzerowany. Powodzenia!'); }

    // Nowa gra: czyÅ›ci punkty i wymusza dodanie co najmniej jednego X (wskazÃ³wka + 4-cyfrowy PIN)
    async function startNewGame() {
      if (!confirm('RozpoczÄ…Ä‡ nowÄ… grÄ™? Aktualne punkty zostanÄ… usuniÄ™te.')) return;
      TREASURES = []; state.found.clear(); saveFound(); refreshMarkers();
      state.editing = true; setClue('Tryb dodawania: stuknij w mapÄ™, aby dodaÄ‡ X.');
      toast('Dodaj co najmniej jeden X.');
      // Po dodaniu pierwszego X zapytamy, czy dodaÄ‡ kolejny (w handlerze klikniÄ™cia mapy)
    }

    // Klik na mapie â€“ dodawanie X z wymaganymi danymi (tylko w trybie edycji)
    map.on('click', (e) => {
      const px = latLngToPx(e.latlng);
      lastTapPx = { x: px.x, y: px.y };
      if (state.editing && state.imageSize) {
        const id = 'X' + (TREASURES.length + 1);
        const posPct = [ Math.round((px.x/state.imageSize.w)*100), Math.round((px.y/state.imageSize.h)*100) ];
        let name = prompt('Nazwa (wskazÃ³wka) dla tego skarbu:');
        if (name === null) return; name = name.trim();
        if (!name) { toast('Wpisz nazwÄ™/wskazÃ³wkÄ™.'); return; }
        let pin = prompt('Ustal 4-cyfrowe hasÅ‚o dla tego skarbu:');
        if (pin === null) return;
        pin = pin.trim();
        if (!/^\d{4}$/.test(pin)) { toast('HasÅ‚o musi mieÄ‡ dokÅ‚adnie 4 cyfry.'); return; }
        const newTreasure = { id, posPct, title: name, hint: name, pin };
        TREASURES.push(newTreasure);
        addMarker(newTreasure);
        updateProgressUI();
        setClue(`Dodano ${id}: ${name}.`);
        // Pytanie o kolejny X
        const more = confirm('DodaÄ‡ kolejny X?');
        if (!more) { state.editing = false; setClue('Gra rozpoczÄ™ta! Klikaj X i wpisuj hasÅ‚o, aby zdobywaÄ‡ skarby.'); }
      }
    });

    // Przyciski
    document.getElementById('hintBtn').addEventListener('click', showHint);
    document.getElementById('resetBtn').addEventListener('click', resetProgress);
    document.getElementById('newGameBtn').addEventListener('click', startNewGame);

    // Init + PWA
    (async function init() {
      const img = new Image(); img.crossOrigin = 'anonymous';
      img.onload = () => {
        state.imageSize = { w: img.naturalWidth, h: img.naturalHeight };
        const w = state.imageSize.w, h = state.imageSize.h;
        const southWest = map.unproject([0, h], getMaxZoomForImage());
        const northEast = map.unproject([w, 0], getMaxZoomForImage());
        const bounds = new L.LatLngBounds(southWest, northEast);
        L.imageOverlay(MAP_IMAGE_URL, bounds).addTo(map);
        map.fitBounds(bounds);
        map.setMaxBounds(bounds.pad(0.2));
        refreshMarkers();
      };
      img.onerror = () => setClue('Nie udaÅ‚o siÄ™ wczytaÄ‡ obrazu mapy. Upewnij siÄ™, Å¼e plik nowyplan.jpg jest obok index.html.');
      img.src = MAP_IMAGE_URL;

      if ('serviceWorker' in navigator) {
        const swCode = `const CACHE='skarb-cache-v5';
self.addEventListener('install',e=>{self.skipWaiting();e.waitUntil(caches.open(CACHE).then(c=>c.addAll(['./','./index.html','./nowyplan.jpg'])))});
self.addEventListener('activate',e=>clients.claim());
self.addEventListener('fetch',e=>{e.respondWith(caches.match(e.request).then(r=>r||fetch(e.request).then(res=>{const copy=res.clone(); caches.open(CACHE).then(c=>c.put(e.request,copy)); return res;})).catch(()=>caches.match('./index.html')))});`;
        const swBlob = new Blob([swCode], {type: 'text/javascript'});
        const swUrl = URL.createObjectURL(swBlob);
        window.addEventListener('load', () => navigator.serviceWorker.register(swUrl));
      }
    })();
  </script>
</body>
</html>
